Culinary Visual Search Engine — Backend Overview
===================================================

Overview
--------
This backend system powers a specialized visual search engine designed for the culinary domain. It utilizes a fine-tuned CLIP model to understand both food images and textual descriptions, combined with FAISS for high-speed similarity search. The API is built using FastAPI for efficiency and scalability.

---------------------------------------------------

System Architecture
-------------------

The backend is organized into two primary Python scripts for better structure and maintainability:

1. main.py – Core Application Logic
------------------------------------
Purpose:
Defines the main FastAPI application (app). Handles all AI-related logic, including model loading, vector indexing, and API route definitions.

Key Responsibilities:
- Load the fine-tuned CLIP model and processor.
- Load FAISS vector indexes (for images and text captions).
- Load metadata mappings (linking index positions to image paths/captions).
- Define API endpoints for search operations.
- Implement search logic for both text-to-image and image-to-text queries.
- Serve static images via StaticFiles for frontend display.

How it Works:
When the server starts, load_backend_resources() initializes all AI components and mappings.
- For /search_images, text queries are converted into CLIP embeddings → FAISS index retrieves top matches → image paths are returned as JSON.
- For /search_text, an uploaded image or image URL is processed → FAISS index retrieves matching textual captions → returned as JSON.

Think of it as: The brain of the system — it holds all intelligence and search logic.

2. server.py – Server Runner & Ngrok Tunneling
----------------------------------------------
Purpose:
Starts the FastAPI web server and handles ngrok tunneling, enabling public access (especially useful for Google Colab environments).

Key Responsibilities:
- Import and launch the FastAPI app from main.py.
- Initialize ngrok using an authentication token.
- Create a secure public tunnel to the local server (port 5000).
- Display the public URL for frontend access.
- Gracefully close the tunnel when the server stops.

Think of it as: The ignition key — starts the engine (main.py) and connects it to the internet.

---------------------------------------------------

API Endpoints & Frontend Interaction
------------------------------------

The frontend communicates with the backend via the ngrok public URL generated by server.py. This URL changes every time the server is restarted.

Demo 1: Text → Image Search
---------------------------
Goal: User enters a text description; backend returns visually matching food images.

Endpoint:
POST <ngrok_public_url>/search_images

Request (JSON):
{"query": "User's search text"}

Response (JSON):
{
  "message": "Found X images...",
  "results": [
    {"image_path": "images/filename.jpg", "distance": 0.X}
  ]
}

Frontend Tasks:
- Provide a text box and search button.
- On click → send text query to /search_images.
- Receive JSON → display message and images.
- Construct full image URL:
  <ngrok_public_url>/static_images/<image_path>
- Display images using <img> tags (not raw paths).

Demo 2: Image → Text Search (Caption Retrieval)
-----------------------------------------------
Goal: User uploads an image; backend returns matching textual descriptions.

Endpoint:
POST <ngrok_public_url>/search_text

Request (Form Data):
- Image file OR
- image_url field

Response (JSON):
{
  "message": "Found X relevant descriptions...",
  "results": [
    {"caption": "Retrieved description...", "distance": 0.Y}
  ]
}

Frontend Tasks:
- Provide an image upload option or image URL input.
- On click → send data to /search_text.
- Display returned captions in a readable list format.

---------------------------------------------------

Desktop Application Behavior
----------------------------

Desired Outcome:
A user should be able to double-click a desktop icon that:
1. Starts the backend server automatically.
2. Opens the web-based interface for interaction.

Implementation Approach:
Use tools like Electron or Tauri to package the app.

Packaging Steps:
1. Bundle frontend (HTML/CSS/JS) files.
2. Configure to auto-run server.py in the background on launch.
3. The app window loads the frontend UI.
4. Frontend connects to the local backend (http://localhost:5000) instead of ngrok (for local setups).

---------------------------------------------------

Icon & Design
-------------

Icon Theme:
A culinary-inspired design (e.g., Chrome-like icon with a chef’s hat).

Used for:
- Desktop application executable icon.
- Favicon for the web version.

---------------------------------------------------

Notes for Frontend Team
-----------------------
- Primary goal: Build the web frontend that correctly interacts with backend APIs through the ngrok public URL.
- Later stage: Package everything into a desktop app using Electron or Tauri.
